{
  "name": "backoff",
  "description": "Fibonacci and exponential backoffs.",
  "version": "1.0.0",
  "author": {
    "name": "Mathieu Turcotte",
    "email": "turcotte.mat@gmail.com"
  },
  "keywords": [
    "backoff",
    "fibonacci",
    "exponential"
  ],
  "repository": {
    "type": "git",
    "url": "https://github.com/MathieuTurcotte/node-backoff.git"
  },
  "devDependencies": {
    "sinon": "1.4",
    "nodeunit": "0.7",
    "jshint": "0.7"
  },
  "scripts": {
    "pretest": "node_modules/jshint/bin/hint lib/*.js lib/strategy/*.js tests/*.js examples/*.js",
    "test": "node_modules/nodeunit/bin/nodeunit tests/"
  },
  "engines": {
    "node": ">= 0.6"
  },
  "readme": "# Backoff for Node.js [![Build Status](https://secure.travis-ci.org/MathieuTurcotte/node-backoff.png?branch=master)](http://travis-ci.org/MathieuTurcotte/node-backoff)\n\nFibonacci and exponential backoffs for Node.js.\n\n## Installation\n```\nnpm install backoff\n```\n## Usage\n\nIn order to use backoff, require `backoff`.\n\n```js\nvar backoff = require('backoff');\n```\n\nThe usual way to instantiate a new `Backoff` object is to use one predefined\nfactory method: `backoff.fibonacci([options])`, `backoff.exponential([options])`.\n\n`Backoff` inherits from `EventEmitter`. When a backoff starts, a `backoff`\nevent is emitted and, when a backoff ends, a `ready` event is emitted.\nHandlers for these two events are called with the current backoff number and\ndelay.\n\n``` js\nvar fibonacciBackoff = backoff.fibonacci({\n    randomisationFactor: 0,\n    initialDelay: 10,\n    maxDelay: 1000\n});\n\nfibonacciBackoff.on('backoff', function(number, delay) {\n    // Do something when backoff starts.\n    console.log(number + ' ' + delay + 'ms');\n});\n\nfibonacciBackoff.on('ready', function(number, delay) {\n    // Do something when backoff ends.\n    if (number < 15) {\n        fibonacciBackoff.backoff();\n    }\n});\n\nfibonacciBackoff.backoff();\n```\n\nThe previous example would print:\n\n```\n0 10ms\n1 10ms\n2 20ms\n3 30ms\n4 50ms\n5 80ms\n6 130ms\n7 210ms\n8 340ms\n9 550ms\n10 890ms\n11 1000ms\n12 1000ms\n13 1000ms\n14 1000ms\n15 1000ms\n```\n\nBackoff objects are meant to be instantiated once and reused several times\nby calling `reset` after a successful \"retry\".\n\n## API\n\n### backoff.fibonacci([options])\n\nConstructs a Fibonacci backoff (10, 10, 20, 30, 50, etc.).\n\nSee bellow for the options description.\n\n### backoff.exponential([options])\n\nConstructs an exponential backoff (10, 20, 40, 80, etc.).\n\nThe options are:\n\n- randomisationFactor: defaults to 0, must be between 0 and 1\n- initialDelay: defaults to 100 ms\n- maxDelay: defaults to 10000 ms\n\nWith these values, the backoff delay will increase from 100 ms to 10000 ms. The\nrandomisation factor controls the range of randomness and must be between 0\nand 1. By default, no randomisation is applied on the backoff delay.\n\n### Class Backoff\n\n#### new Backoff(strategy)\n\n- strategy: the backoff strategy to use\n\nConstructs a new backoff object from a specific backoff strategy. The backoff\nstrategy must implement the `BackoffStrategy`interface defined bellow.\n\n#### backoff.backoff()\n\nStarts a backoff operation. Will throw an error if a backoff operation is\nalready in progress.\n\nIn practice, this method should be called after a failed attempt to perform a\nsensitive operation (connecting to a database, downloading a resource over the\nnetwork, etc.).\n\n#### backoff.reset()\n\nResets the backoff delay to the initial backoff delay and stop any backoff\noperation in progress. After reset, a backoff instance can and should be\nreused.\n\nIn practice, this method should be called after having successfully completed\nthe sensitive operation guarded by the backoff instance or if the client code\nrequest to stop any reconnection attempt.\n\n#### Event: 'backoff'\n\n- number: number of backoffs since last reset, starting at 0\n- delay: backoff delay in milliseconds\n\nEmitted when a backoff operation is started. Signals to the client how long\nthe next backoff delay will be.\n\n#### Event: 'ready'\n\n- number: number of backoffs since last reset, starting at 0\n- delay: backoff delay in milliseconds\n\nEmitted when a backoff operation is done. Signals that the failing operation\nshould be retried.\n\n### Interface BackoffStrategy\n\nA backoff strategy must provide the following methods.\n\n#### strategy.next()\n\nComputes and returns the next backoff delay.\n\n#### strategy.reset()\n\nResets the backoff delay to its initial value.\n\n### Class ExponentialStrategy\n\nExponential (10, 20, 40, 80, etc.) backoff strategy implementation.\n\n#### new ExponentialStrategy([options])\n\nThe options are:\n\n- randomisationFactor: defaults to 0, must be between 0 and 1\n- initialDelay: defaults to 100 ms\n- maxDelay: defaults to 10000 ms\n\n### Class FibonacciStrategy\n\nFibonnaci (10, 10, 20, 30, 50, etc.) backoff strategy implementation.\n\n#### new FibonacciStrategy([options])\n\nThe options are:\n\n- randomisationFactor: defaults to 0, must be between 0 and 1\n- initialDelay: defaults to 100 ms\n- maxDelay: defaults to 10000 ms\n\n## License\n\nThis code is free to use under the terms of the [MIT license](http://mturcotte.mit-license.org/).\n",
  "_id": "backoff@1.0.0",
  "_from": "backoff@~1.0.0"
}
