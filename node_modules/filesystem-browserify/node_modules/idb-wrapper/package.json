{
  "name": "idb-wrapper",
  "version": "0.3.1",
  "description": "A cross-browser wrapper for IndexedDB",
  "keywords": [],
  "author": {
    "name": "jensarps",
    "email": "mail@jensarps.de",
    "url": "http://jensarps.de/"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/jensarps/IDBWrapper.git"
  },
  "main": "idbstore",
  "homepage": "https://github.com/jensarps/IDBWrapper",
  "contributors": [
    {
      "name": "Josh Matthews",
      "email": "josh@joshmatthews.net",
      "url": "http://www.joshmatthews.net/blog/"
    },
    {
      "name": "Raynos",
      "email": "raynos2@gmail.com",
      "url": "http://raynos.org"
    }
  ],
  "bugs": {
    "url": "https://github.com/jensarps/IDBWrapper/issues",
    "email": "mail@jensarps.de"
  },
  "dependencies": {},
  "devDependencies": {},
  "licenses": [
    {
      "type": "MIT",
      "url": "http://github.com/jensarps/IDBWrapper/raw/master/LICENSE"
    }
  ],
  "scripts": {},
  "readme": "About\n=====\n\nThis is a wrapper for indexedDB. It is meant to\n\na) ease the use of indexedDB and abstract away the differences between the\nexisting impls in Chrome, Firefox and IE10 (yes, it works in all three), and\n\nb) show how IDB works. The code is split up into short methods, so that it's\neasy to see what happens in what method.\n\n\"Showing how it works\" is the main intention of this project. IndexedDB is\nall the buzz, but only a few people actually know how to use it.\n\nThe code in IDBWrapper.js is not optimized for anything, nor minified or anything.\nIt is meant to be read and easy to understand. So, please, go ahead and check out\nthe source!\n\nThere are two tutorials to get you up and running:\n\nPart 1: Setup and CRUD operations\nhttp://jensarps.de/2011/11/25/working-with-idbwrapper-part-1/\n\nPart 2: Running Queries against the store\nhttp://jensarps.de/2012/11/13/working-with-idbwrapper-part-2/\n\n##November Rewrite\n\nI rewrote IDBWrapper to cope with all the issues, and the new version is on\nmaster since Nov, 13th 2012. The API didn't change much, I just removed some\nof the methods. Method signatures remain unchanged.\n\nHowever, if you have a previous version of IDBWrapper in use, there's an\nissue: The new version won't be able to access the store created with the old\nversion, because database names changed. In that case, you need to manually\nmigrate the data: Include both versions of IDBWrapper (use a different name for\nthem), do a getAll() on the old store and write the data to the new store.\n\nI am very sorry about any inconveniences, but there was no other way.\n\nThe 'old' version of IDBWrapper is still available in the `legacy` branch:\nhttps://github.com/jensarps/IDBWrapper/tree/legacy\n\nAlso, \"showing how it works\" is no longer the main intention behind this. Now,\nit's rather \"just works\".\n\n\nExamples\n========\n\nThere are some examples to run right in your browser over here: http://jensarps.github.com/IDBWrapper/example/\n\nThe source for these examples are in the `example` folder of this repository.\n\nUsage\n=====\n\nIncluding the idbstore.js file will add an IDBStore constructor to the global scope.\n\nAlternatively, you can use an AMD loader such as RequireJS, or a CommonJS loader\nto load the module, and you will receive the constructor in your load callback\n(the constructor will then, of course, have whatever name you call it).\n\nYou can then create an IDB store:\n\n```javascript\nvar myStore = new IDBStore();\n```\n\nYou may pass two parameters to the constructor: the first is an object with optional parameters,\nthe second is a function reference to a function that is called when the store is ready to use.\n\nThe options object may contain the following properties (default values are shown):\n\n```javascript\n{\n  storeName: 'Store',\n  dbVersion: 1,\n  keyPath: 'id',\n  autoIncrement: true,\n  indexes: [],\n  onStoreReady: function(){},\n  onError: function(error){ throw error; }\n}\n```\n\n'keyPath' is the name of the property to be used as key index. If 'autoIncrement' is set to true,\nthe database will automatically add a unique key to the keyPath index when storing objects missing\nthat property. 'indexes' contains objects defining indexes (see below for details on indexes).\n\n'onError' gets called if an error occurred while trying to open the store. It\nreceives the error instance as only argument.\n\nAs an alternative to passing a ready handler as second argument, you can also\npass it in the 'onStoreReady' property. If a callback is provided both as second\nparameter and inside of the options object, the function passed as second\nparameter will be used.\n\nMethods\n=======\n\nHere's an overview of available methods in IDBStore:\n\nData Manipulation\n-----------------\n\nUse the following methods to read and write data:\n\n___\n\n\n1) The put method.\n\n\n```javascript\nput(/*Object*/ dataObj, /*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`dataObj` is the Object to store. `onSuccess` will be called when the insertion/update was successful,\nand it will receive the keyPath value (the id, so to say) of the inserted object as first and only\nargument. `onError` will be called if the insertion/update failed and it will receive the error event\nobject as first and only argument. If the store already contains an object with the given keyPath id,\nit will be overwritten by `dataObj`.\n\n___\n\n\n2) The get method.\n\n```javascript\nget(/*keyPath value*/ key, /*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`key` is the keyPath property value (the id) of the object to retrieve. `onSuccess` will be called if\nthe get operation was successful, and it will receive the stored object as first and only argument. If\nno object was found with the given keyPath value, this argument will be null. `onError` will be called\nif the get operation failed and it will receive the error event object as first and only argument.\n\n___\n\n\n3) The getAll method.\n\n```javascript\ngetAll: function(/*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`onSuccess` will be called if the getAll operation was successful, and it will receive an Array of\nall objects currently stored in the store as first and only argument. `onError` will be called if\nthe getAll operation failed and it will receive the error event object as first and only argument.\n\n___\n\n\n4) The remove method.\n\n```javascript\nremove: function(/*keyPath value*/ key, /*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`key` is the keyPath property value (the id) of the object to remove. `onSuccess` will be called if\nthe remove operation was successful, and it _should_ receive `false` as first and only argument if the\nobject to remove was not found, and `true` if it was found and removed.\n\nNOTE: FF 8 will pass the key to the onSuccess handler, no matter if there is an corresponding object\nor not. Chrome 15 will pass `null` if removal was successful, and call the error handler if the object\nwasn't found. Chrome 17 will behave as described above.\n\n`onError` will be called if the remove operation failed and it will receive the error event object as first\nand only argument.\n\n___\n\n\n5) The clear method.\n\n```javascript\nclear: function(/*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`onSuccess` will be called if the clear operation was successful. `onError` will be called if the clear\noperation failed and it will receive the error event object as first and only argument.\n\n___\n\n\n6) The batch method.\n\n```javascript\nbatch: function (/*Array*/operations, /*Function?*/onSuccess, /*Function?*/onError)\n```\n\n`batch` expects an array of operations that you want to apply in a single\nIndexedDB transaction. `operations` is an Array of objects, each containing two\nproperties, defining the type of operation. There are two operations\nsupported, put and remove. A put entry looks like this:\n\n```javascript\n{ type: \"put\", value: dataObj } // dataObj being the object to store\n```\n\nA remove entry looks like this;\n\n```javascript\n{ type: \"remove\", key: someKey } // someKey being the keyPath value of the item to remove\n```\n\nYou can mix both types in the `operations` Array:\n\n```javascript\nbatch([\n  { type: \"put\", value: dataObj },\n  { type: \"remove\", key: someKey }\n], onSuccess, onError)\n```\n\n`onSuccess` will be called if all operations were successful and will receive no\narguments. `onError` will be called if an error happens for one of the\noperations and will receive three arguments: the Error instance, the type of\noperation that caused the error and either the key or the value property\n(depending on the type).\n\nIf an error occurs, no changes will be made to the store, even if some\nof the given operations would have succeeded.\n\n\nIndex Operations\n----------------\n\nTo create indexes, you need to pass the index information to the IDBStore()\nconstructor, for example:\n\n\n```javascript\n{\n  storeName: 'customers',\n  dbVersion: 1,\n  keyPath: 'customerid',\n  autoIncrement: true,\n  onStoreReady: function(){},\n  indexes: [\n    { name: 'lastname', keyPath: 'lastname', unique: false, multiEntry: false }\n  ]\n}\n```\n\nAn entry in the index Array is an object containing the following properties:\n\nThe `name` property is the identifier of the index. If you want to work with the created index later, this name is used to identify the index. This is the only property that is mandatory.\n\nThe `keyPath` property is the name of the property in your stored data that you want to index. If you omit that, IDBWrapper will assume that it is the same as the provided name, and will use this instead.\n\nThe `unique` property tells the store whether the indexed property in your data is unique. If you set this to true, it will add a uniqueness constraint to the store which will make it throw if you try to store data that violates that constraint. If you omit that, IDBWrapper will set this to false.\n\nThe `multiEntry` property is kinda weird. You can read up on it here: http://www.w3.org/TR/IndexedDB/#dfn-multientry. However, you can live perfectly fine with setting this to false (or just omitting it, this is set to false by default).\n\n\nIf you want to add an index to an existing store, you need to increase the\nversion number of your store, as adding an index changes the structure of\nthe database.\n\nTo modify an index, modify the object in the indexes Array in the constructor.\nAgain, you need to increase the version of your store.\n\nIn addition, there are still some convenience methods available:\n\n___\n\n\n1) The hasIndex method.\n\n```javascript\nhasIndex: function(/*String*/ indexName)\n```\n\nReturn true if an index with the given name exists in the store, false if not.\n\n___\n\n2) The getIndexList method.\n\n```javascript\ngetIndexList: function()\n```\n\nReturns a `DOMStringList` with all existing indices.\n\n\nRunning Queries\n---------------\n\nTo run queries, IDBWrapper provides an `iterate()` method. To create keyRanges,\nthere is the `makeKeyRange()` method. In addition to these, IDBWrapper comes\nwith a `count()` method.\n\n___\n\n\n1) The iterate method.\n\n\n```javascript\niterate: function(/*Function*/ onItem, /*Object*/ iterateOptions)\n```\n\nThe `onItem` callback will be called once for every match. It will receive three arguments: the object that matched the query, a reference to the current cursor object (IDBWrapper uses IndexedDB's Cursor internally to iterate), and a reference to the current ongoing transaction.\n\nThere's one special situation: if you didn't pass an onEnd handler in the options objects (see below), the onItem handler will be called one extra time when the transaction is over. In this case, it will receive null as only argument. So, to check when the iteration is over and you won't get any more data objects, you can either pass an onEnd handler, or check for null in the onItem handler.\n\nThe `iterateOptions` object can contain one or more of the following properties:\n\n\nThe `index` property contains the name of the index to operate on. If you omit this, IDBWrapper will use the store's keyPath as index.\n\nIn the `keyRange` property you can pass a keyRange.\n\nThe `order` property can be set to 'ASC' or 'DESC', and determines the ordering direction of results. If you omit this, IDBWrapper will use 'ASC'.\n\nThe `filterDuplicates` property is an interesting one: If you set this to true (it defaults to false), and have several objects that have the same value in their key, the store will only fetch the first of those. It is not about objects being the same, it's about their key being the same. For example, in the customers database are a couple of guys having 'Smith' as last name. Setting filterDuplicates to true in the above example will make `iterate()` call the onItem callback only for the first of those.\n\nThe `writeAccess` property defaults to false. If you need write access to the store during the iteration, you need to set this to true.\n\nIn the `onEnd` property you can pass a callback that gets called after the iteration is over and the transaction is closed. It does not receive any arguments.\n\nIn the `onError` property you can pass a custom error handler. In case of an error, it will be called and receives the Error object as only argument.\n\n___\n\n\n2) The makeKeyRange method.\n\n\n```javascript\nmakeKeyRange: function(/*Object*/ keyRangeOptions)\n```\n\nReturns an IDBKeyRange.\n\nThe `keyRangeOptions` object must have one or more of the following properties:\n\n`lower`: The lower bound of the range\n\n`excludeLower`: Boolean, whether to exclude the lower bound itself. Default: false\n\n`upper`: The upper bound of the range\n\n`excludeUpper`: Boolean, whether to exclude the upper bound itself. Default: false\n\n___\n\n\n3) The count method.\n\n\n```javascript\ncount: function(/*Function*/ onSuccess, /*Object*/ countOptions)\n```\n\nThe onSuccess receives the result of the count as only argument.\n\nThe `countOptions` object may have one or more of the following properties:\n\nindex: The name of an index to operate on.\n\nkeyRange: A keyRange to use\n\n",
  "_id": "idb-wrapper@0.3.1",
  "dist": {
    "shasum": "44d045f899b13e450c87344f5ee9163bcd04af27"
  },
  "_from": "idb-wrapper@~0.3.1"
}
